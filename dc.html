<html>
    <head>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    </head>
    <body style="margin:0;padding:0">
        <canvas></canvas>
    </body>
</html>
<script type="module">
	const
		cas = document.body.firstElementChild,
		ctx = cas.getContext('2d'),
		xc = Math.ceil(document.body.offsetWidth / 2),
		yc = Math.ceil(document.body.offsetHeight / 2),
		sp = [];
	cas.width = document.body.offsetWidth;
	cas.height = document.body.offsetHeight;
	ctx.lineWidth = 2;

	function ctx_clear()
	{
		ctx.clearRect(0, 0, cas.width, cas.height);
	}
	function ctx_draw()
	{
		ctx_clear();
		for (let i = 0; i < sp.length; ++i)
		{
			sp[i]();
		}
	}

	await new Promise((resolve) =>
	{
		let current = 0, finish = 300, reloop = setInterval(() =>
		{
			ctx_draw();
			current += 3;
			if (current > finish)
			{
				clearInterval(reloop);
				current = finish;
				resolve(() =>
				{
					ctx.beginPath();
					ctx.strokeRect(xc - 150, yc - 350, 300, 150);
				});
			}
			ctx.beginPath();
			ctx.moveTo(xc - 150, yc - 350);
			ctx.lineTo(xc - 150 + current, yc - 350);

			ctx.moveTo(xc - 150, yc - 350);
			ctx.lineTo(xc - 150, yc - 350 + current * 0.5);
			
			ctx.moveTo(xc + 150, yc - 200);
			ctx.lineTo(xc + 150 - current, yc - 200);

			ctx.moveTo(xc + 150, yc - 200);
			ctx.lineTo(xc + 150, yc - 200 - current * 0.5);

			ctx.stroke();

		}, 20);

	}).then((fn) => sp[sp.length] = fn);


	await new Promise((resolve) =>
	{
		let current = ['玛', '酷', '一', '兆', '韦', '德', '编', '程', '中', '心'], finish = [], reloop = setInterval(() =>
		{
			ctx_draw();
			finish[finish.length] = current.shift();
			if (current.length === 0)
			{
				clearInterval(reloop);
				resolve(() =>
				{
					ctx.font = "21px serif";
					ctx.fillText(finish.join(''), xc - 80, yc - 300);
				});
			}
			ctx.font = "21px serif";
			ctx.fillText(finish.join(''), xc - 80, yc - 300);
		}, 200);

	}).then((fn) => sp[sp.length] = fn);


	await new Promise((resolve) =>
	{
		let current = 0, finish = Math.PI * 2, reloop = setInterval(() =>
		{
			ctx_draw();
			current += 0.1;
			if (current > finish)
			{
				clearInterval(reloop);
				current = finish;
				resolve(() =>
				{
					ctx.beginPath();
					ctx.arc(xc - 120, yc - 300, 27, 0, current, false);
					ctx.stroke();
					ctx.beginPath();
					ctx.arc(xc - 130, yc - 306, 4, 0, current, false);
					ctx.stroke();
					ctx.beginPath();
					ctx.arc(xc - 110, yc - 306, 4, 0, current, false);
					ctx.stroke();
					ctx.beginPath();
					ctx.arc(xc - 120, yc - 300, 18, 0, current * 0.5, false);
					ctx.stroke();
				});
			}
			ctx.beginPath();
			ctx.arc(xc - 120, yc - 300, 27, 0, current, false);
			ctx.stroke();

			ctx.beginPath();
			ctx.arc(xc - 130, yc - 306, 4, 0, current, false);
			ctx.stroke();

			ctx.beginPath();
			ctx.arc(xc - 110, yc - 306, 4, 0, current, false);
			ctx.stroke();

			ctx.beginPath();
			ctx.arc(xc - 120, yc - 300, 18, 0, current * 0.5, false);
			ctx.stroke();

		}, 20);
	}).then((fn) => sp[sp.length] = fn);




	await new Promise((resolve, reject) =>
	{


		ctx_draw();
		console.log(1);

	}).then((fn) => sp[sp.length] = fn);




	console.log(ctx)
</script>